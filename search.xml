<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C-primer-5th-阅读笔记第三章</title>
      <link href="/2022/07/10/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2022/07/10/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h1><h2 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h2><ul><li>使用某个命名空间：例如 <code>using std::cin</code>表示使用命名空间<code>std</code>中的名字<code>cin</code>。</li><li>头文件中不应该包含<code>using</code>声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。</li></ul><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li>标准库类型<code>string</code>表示可变长的字符序列。</li><li><code>#include &lt;string&gt;</code>，然后 <code>using std::string;</code></li><li><strong>string对象</strong>：注意，不同于字符串字面值。</li></ul><h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>初始化<code>string</code>对象的方式：</p><table><thead><tr><th>方式</th><th>解释</th></tr></thead><tbody><tr><td><code>string s1</code></td><td>默认初始化，<code>s1</code>是个空字符串</td></tr><tr><td><code>string s2(s1)</code></td><td><code>s2</code>是<code>s1</code>的副本</td></tr><tr><td><code>string s2 = s1</code></td><td>等价于<code>s2(s1)</code>，<code>s2</code>是<code>s1</code>的副本</td></tr><tr><td><code>string s3(&quot;value&quot;)</code></td><td><code>s3</code>是字面值“value”的副本，除了字面值最后的那个空字符外</td></tr><tr><td><code>string s3 = &quot;value&quot;</code></td><td>等价于<code>s3(&quot;value&quot;)</code>，<code>s3</code>是字面值”value”的副本</td></tr><tr><td><code>string s4(n, &#39;c&#39;)</code></td><td>把<code>s4</code>初始化为由连续<code>n</code>个字符<code>c</code>组成的串</td></tr></tbody></table><ul><li>拷贝初始化（copy initialization）：使用等号<code>=</code>将一个已有的对象拷贝到正在创建的对象。</li><li>直接初始化（direct initialization）：通过括号给对象赋值。</li></ul><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p><code>string</code>的操作：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>os &lt;&lt; s</code></td><td>将<code>s</code>写到输出流<code>os</code>当中，返回<code>os</code></td></tr><tr><td><code>is &gt;&gt; s</code></td><td>从<code>is</code>中读取字符串赋给<code>s</code>，字符串以空白分割，返回<code>is</code></td></tr><tr><td><code>getline(is, s)</code></td><td>从<code>is</code>中读取一行赋给<code>s</code>，返回<code>is</code></td></tr><tr><td><code>s.empty()</code></td><td><code>s</code>为空返回<code>true</code>，否则返回<code>false</code></td></tr><tr><td><code>s.size()</code></td><td>返回<code>s</code>中字符的个数</td></tr><tr><td><code>s[n]</code></td><td>返回<code>s</code>中第<code>n</code>个字符的引用，位置<code>n</code>从0计起</td></tr><tr><td><code>s1+s2</code></td><td>返回<code>s1</code>和<code>s2</code>连接后的结果</td></tr><tr><td><code>s1=s2</code></td><td>用<code>s2</code>的副本代替<code>s1</code>中原来的字符</td></tr><tr><td><code>s1==s2</code></td><td>如果<code>s1</code>和<code>s2</code>中所含的字符完全一样，则它们相等；<code>string</code>对象的相等性判断对字母的大小写敏感</td></tr><tr><td><code>s1!=s2</code></td><td>同上</td></tr><tr><td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td><td>利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较）</td></tr></tbody></table><ul><li>string io：<ul><li>执行读操作<code>&gt;&gt;</code>：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。</li><li><code>getline</code>：读取一整行，<strong>包括空白符</strong>。</li></ul></li><li><code>s.size()</code>返回的时<code>string::size_type</code>类型，记住是一个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</li><li><code>s1+s2</code>使用时，保证至少一侧是string类型。<code>string s1 = &quot;hello&quot; + &quot;world&quot; // 错误，两侧均为字符串字面值</code></li><li><strong>字符串字面值和string是不同的类型。</strong></li></ul><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><ul><li><p><strong>ctype.h vs. cctype</strong>：C++修改了c的标准库，名称为去掉<code>.h</code>，前面加<code>c</code>。</p><blockquote><p>如c++版本为<code>cctype</code>，c版本为<code>ctype.h</code></p></blockquote><ul><li><strong>尽量使用c++版本的头文件</strong>，即<code>cctype</code></li></ul></li></ul><p><code>cctype</code>头文件中定义了一组标准函数：</p><table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody><tr><td><code>isalnum(c)</code></td><td>当<code>c</code>是字母或数字时为真</td></tr><tr><td><code>isalpha(c)</code></td><td>当<code>c</code>是字母时为真</td></tr><tr><td><code>iscntrl(c)</code></td><td>当<code>c</code>是控制字符时为真</td></tr><tr><td><code>isdigit(c)</code></td><td>当<code>c</code>是数字时为真</td></tr><tr><td><code>isgraph(c)</code></td><td>当<code>c</code>不是空格但可以打印时为真</td></tr><tr><td><code>islower(c)</code></td><td>当<code>c</code>是小写字母时为真</td></tr><tr><td><code>isprint(c)</code></td><td>当<code>c</code>是可打印字符时为真</td></tr><tr><td><code>ispunct(c)</code></td><td>当<code>c</code>是标点符号时为真</td></tr><tr><td><code>isspace(c)</code></td><td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td></tr><tr><td><code>isupper(c)</code></td><td>当<code>c</code>是大写字母时为真</td></tr><tr><td><code>isxdigit(c)</code></td><td>当<code>c</code>是十六进制数字时为真</td></tr><tr><td><code>tolower(c)</code></td><td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td></tr><tr><td><code>toupper(c)</code></td><td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td></tr></tbody></table><ul><li>遍历字符串：使用<strong>范围for</strong>（range for）语句： <code>for (auto c: str)</code>，或者 <code>for (auto &amp;c: str)</code>使用引用直接改变字符串中的字符。 （C++11）</li><li><code>str[x]</code>,[]输入参数为<code>string::size_type</code>类型，给出<code>int</code>整型也会自动转化为该类型</li></ul><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul><li>vector是一个<strong>容器</strong>，也是一个类模板；</li><li><code>#include &lt;vector&gt;</code> 然后 <code>using std::vector;</code></li><li>容器：包含其他对象。</li><li>类模板：本身不是类，但可以<strong>实例化instantiation</strong>出一个类。 <code>vector</code>是一个模板， <code>vector&lt;int&gt;</code>是一个类型。</li><li>通过将类型放在类模板名称后面的<strong>尖括号</strong>中来指定<strong>类型</strong>，如<code>vector&lt;int&gt; ivec</code>。</li></ul><h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><p>初始化<code>vector</code>对象的方法</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td><code>vector&lt;T&gt; v1</code></td><td><code>v1</code>是一个空<code>vector</code>，它潜在的元素是<code>T</code>类型的，执行默认初始化</td></tr><tr><td><code>vector&lt;T&gt; v2(v1)</code></td><td><code>v2</code>中包含有<code>v1</code>所有元素的副本</td></tr><tr><td><code>vector&lt;T&gt; v2 = v1</code></td><td>等价于<code>v2(v1)</code>，<code>v2</code>中包含<code>v1</code>所有元素的副本</td></tr><tr><td><code>vector&lt;T&gt; v3(n, val)</code></td><td><code>v3</code>包含了n个重复的元素，每个元素的值都是<code>val</code></td></tr><tr><td><code>vector&lt;T&gt; v4(n)</code></td><td><code>v4</code>包含了n个重复地执行了值初始化的对象</td></tr><tr><td><code>vector&lt;T&gt; v5&#123;a, b, c...&#125;</code></td><td><code>v5</code>包含了初始值个数的元素，每个元素被赋予相应的初始值</td></tr><tr><td><code>vector&lt;T&gt; v5=&#123;a, b, c...&#125;</code></td><td>等价于<code>v5&#123;a, b, c...&#125;</code></td></tr></tbody></table><ul><li>列表初始化： <code>vector&lt;string&gt; v&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;</code> （C++11）</li></ul><h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><ul><li><code>v.push_back(e)</code> 在尾部增加元素。</li></ul><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p><code>vector</code>支持的操作：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>v.emtpy()</code></td><td>如果<code>v</code>不含有任何元素，返回真；否则返回假</td></tr><tr><td><code>v.size()</code></td><td>返回<code>v</code>中元素的个数</td></tr><tr><td><code>v.push_back(t)</code></td><td>向<code>v</code>的尾端添加一个值为<code>t</code>的元素</td></tr><tr><td><code>v[n]</code></td><td>返回<code>v</code>中第<code>n</code>个位置上元素的<strong>引用</strong></td></tr><tr><td><code>v1 = v2</code></td><td>用<code>v2</code>中的元素拷贝替换<code>v1</code>中的元素</td></tr><tr><td><code>v1 = &#123;a,b,c...&#125;</code></td><td>用列表中元素的拷贝替换<code>v1</code>中的元素</td></tr><tr><td><code>v1 == v2</code></td><td><code>v1</code>和<code>v2</code>相等当且仅当它们的元素数量相同且对应位置的元素值都相同</td></tr><tr><td><code>v1 != v2</code></td><td>同上</td></tr><tr><td><code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code></td><td>以字典顺序进行比较</td></tr></tbody></table><ul><li>范围<code>for</code>语句内不应该改变其遍历序列的大小。</li><li><code>vector</code>对象（以及<code>string</code>对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。</li></ul><h2 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h2><ul><li>所有标准库容器都可以使用迭代器。</li><li>类似于指针类型，迭代器也提供了对对象的间接访问。</li></ul><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><ul><li><code>vector&lt;int&gt;::iterator iter</code>。</li><li><code>auto b = v.begin();</code>返回指向第一个元素的迭代器。</li><li><code>auto e = v.end();</code>返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。</li><li>如果容器为空， <code>begin()</code>和 <code>end()</code>返回的是同一个迭代器，都是尾后迭代器。</li><li>使用解引用符<code>*</code>访问迭代器指向的元素。</li><li>养成使用迭代器和<code>!=</code>的习惯（泛型编程）。</li><li><strong>容器</strong>：可以包含其他对象；但所有的对象必须类型相同。</li><li><strong>迭代器（iterator）</strong>：每种标准容器都有自己的迭代器。<code>C++</code>倾向于用迭代器而不是下标遍历元素。</li><li><strong>const_iterator</strong>：只能读取容器内元素不能改变。</li><li><strong>箭头运算符</strong>： 解引用 + 成员访问，<code>it-&gt;mem</code>等价于 <code>(*it).mem</code></li><li><strong>谨记</strong>：但凡是使用了<strong>迭代器</strong>的循环体，都<strong>不要</strong>向迭代器所属的容器<strong>添加元素</strong>。</li></ul><p>标准容器迭代器的运算符:</p><table><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td><code>*iter</code></td><td>返回迭代器<code>iter</code>所指向的<strong>元素的引用</strong></td></tr><tr><td><code>iter-&gt;mem</code></td><td>等价于<code>(*iter).mem</code></td></tr><tr><td><code>++iter</code></td><td>令<code>iter</code>指示容器中的下一个元素</td></tr><tr><td><code>--iter</code></td><td>令<code>iter</code>指示容器中的上一个元素</td></tr><tr><td><code>iter1 == iter2</code></td><td>判断两个迭代器是否相等</td></tr></tbody></table><h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p><code>vector</code>和<code>string</code>迭代器支持的运算：</p><table><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td><code>iter + n</code></td><td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td><code>iter - n</code></td><td>迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td><code>iter1 += n</code></td><td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td></tr><tr><td><code>iter1 -= n</code></td><td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td></tr><tr><td><code>iter1 - iter2</code></td><td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td></tr><tr><td><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td><td>迭代器的关系运算符，如果某迭代器</td></tr></tbody></table><ul><li><strong>difference_type</strong>：保证足够大以存储任何两个迭代器对象间的距离，可正可负。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>相当于vector的低级版，<strong>长度固定</strong>。</li></ul><h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><ul><li>初始化：<code>char input_buffer[buffer_size];</code>，长度必须是const表达式，或者不写，让编译器自己推断。</li><li>数组不允许直接赋值给另一个数组。</li></ul><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ul><li>数组下标的类型：<code>size_t</code> 。</li><li>字符数组的特殊性：结尾处有一个空字符，如 <code>char a[] = &quot;hello&quot;;</code> 。</li><li>用数组初始化 <code>vector</code>： <code>int a[] = &#123;1,2,3,4,5&#125;; vector&lt;int&gt; v(begin(a), end(a));</code> 。</li></ul><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><ul><li>使用数组时，编译器一般会把它转换成指针。</li><li>标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 </li><li><strong>指针访问数组</strong>：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。</li></ul><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><ul><li>从C继承来的字符串。</li><li>用空字符结束（<code>\0</code>）。</li><li>对大多数应用来说，使用标准库 <code>string</code>比使用C风格字符串更安全、更高效。</li><li>获取 <code>string</code> 中的 <code>cstring</code> ： <code>const char *str = s.c_str();</code> 。</li></ul><p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p><table><thead><tr><th>函数</th><th>介绍</th></tr></thead><tbody><tr><td><code>strlen(p)</code></td><td>返回<code>p</code>的长度，空字符不计算在内</td></tr><tr><td><code>strcmp(p1, p2)</code></td><td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td></tr><tr><td><code>strcat(p1, p2)</code></td><td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td></tr><tr><td><code>strcpy(p1, p2)</code></td><td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td></tr></tbody></table><p> <strong>尽量使用vector和迭代器，少用数组</strong></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><ul><li><strong>多维数组的初始化</strong>： &#96;int ia[3][4] &#x3D;</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C-primer-5th-阅读笔记第二章</title>
      <link href="/2022/07/07/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2022/07/07/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><p>任何常用的编程语言都具备一组公共的语法特征，最基本的特征包括：</p><ul><li>整型、字符型等内置类型</li><li>变量，用来为对象命名</li><li>表达式和语句，用于操作上述数据类型的具体值</li><li>if 或 while 等控制结构，有选择地执行一些语句或重复地执行一些语句函数，用于定义可供随时调用的计算单元</li></ul><p>大多数编程语言通过两种方式来进一步补充其基本特征：</p><ul><li>自定义数据类型，实现对语言的扩展</li><li>将一些有用的功能封装成库函数</li></ul><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p><img src="/2022/07/07/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20221011191651582.png" alt="image-20221011191651582"></p><blockquote><p> 数据类型long long 是在C++11中新定义的。</p></blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>非布尔型赋给布尔型，初始值为0则结果为false，否则为true。</li><li>布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。</li></ul><p>当在程序中使用一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b = <span class="number">42</span>;<span class="comment">// b 为真</span></span><br><span class="line"><span class="type">int</span> i = b;<span class="comment">// i 的值为3</span></span><br><span class="line">i = <span class="number">3.14</span>;<span class="comment">// i 的值为3</span></span><br><span class="line"><span class="type">double</span> pi = i;<span class="comment">// pi 的值为 3.0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>; <span class="comment">// 假设 char 占8bit， c 的值为255</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2 = <span class="number">256</span>;<span class="comment">// 假设 char 占8bit, c2 的值是未定义的</span></span><br></pre></td></tr></table></figure><h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><ul><li><p>一个形如<code>42</code>的值被称作<strong>字面值常量</strong>（literal）。</p><ul><li><p>整型和浮点型字面值。</p></li><li><p>字符和字符串字面值。</p><ul><li><p>使用空格连接，继承自C。</p></li><li><p>字符字面值：单引号， <code>&#39;a&#39;</code></p></li><li><p>字符串字面值：双引号， <code>&quot;Hello World&quot;</code></p></li><li><p>分多行书写字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:cout&lt;&lt;<span class="string">&quot;wow, a really, really long string&quot;</span></span><br><span class="line">          <span class="string">&quot;literal that spans two lines&quot;</span> &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>转义序列。<code>\n</code>、<code>\t</code>等。</p></li><li><p>布尔字面值。<code>true</code>，<code>false</code>。</p></li><li><p>指针字面值。<code>nullptr</code></p></li></ul></li></ul><blockquote><p>字符串型实际上时常量字符构成的数组，结尾处以<code>&#39;\0&#39;</code>结束，所以字符串类型实际上长度比内容多1。</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量</strong>提供一个<strong>具名</strong>的、可供程序操作的存储空间。   <code>C++</code>中<strong>变量</strong>和<strong>对象</strong>一般可以互换使用。</p><h3 id="变量定义（define）"><a href="#变量定义（define）" class="headerlink" title="变量定义（define）"></a>变量定义（define）</h3><ul><li><strong>定义形式</strong>：类型说明符（type specifier） + 一个或多个变量名组成的列表。如<code>int sum = 0, value, units_sold = 0;</code></li><li><strong>初始化</strong>（initialize）：对象在创建时获得了一个特定的值。<ul><li><strong>初始化不是赋值！</strong>：</li><li>初始化 &#x3D; 创建变量 + 赋予初始值</li><li>赋值 &#x3D; 擦除对象的当前值 + 用新值代替</li><li><strong>列表初始化</strong>：使用花括号<code>&#123;&#125;</code>，如<code>int units_sold&#123;0&#125;;</code></li><li>默认初始化：定义时没有指定初始值会被默认初始化；<strong>在函数体内部的内置类型变量将不会被初始化</strong>。</li><li>建议初始化每一个内置类型的变量。</li></ul></li></ul><h3 id="变量的声明（declaration）-vs-定义（define）"><a href="#变量的声明（declaration）-vs-定义（define）" class="headerlink" title="变量的声明（declaration） vs 定义（define）"></a>变量的<strong>声明</strong>（declaration） vs <strong>定义</strong>（define）</h3><ul><li><p>为了支持分离式编译，<code>C++</code>将声明和定义区分开。<strong>声明</strong>使得名字为程序所知。<strong>定义</strong>负责创建与名字关联的实体。</p></li><li><p><strong>extern</strong>：只是说明变量定义在其他地方。</p></li><li><p>只声明而不定义： 在变量名前添加关键字 <code>extern</code>，如<code>extern int i;</code>。但如果包含了初始值，就变成了定义：<code>extern double pi = 3.14;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;           <span class="comment">// 声明i而非定义i</span></span><br><span class="line"><span class="type">int</span> j;                  <span class="comment">// 声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.14</span> <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></li><li><p>变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。</p></li></ul><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><ul><li>第一次使用变量时再定义它。</li><li>但是用到全局变量时，尽量不适用重名的局部变量。</li></ul><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>一般说的引用是指的左值引用 </p></blockquote><p><strong>引用</strong> 就是为变量（对象）起一个别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> val1 = <span class="number">102</span>;</span><br><span class="line"><span class="type">int</span>&amp; refVal = val;<span class="comment">//refVal指向val</span></span><br><span class="line">refVal = val1;<span class="comment">//refVal引用并没有改变，只是改变了refVal指向的变量val的值，val = val1</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;<span class="comment">//错误，引用必须初始化</span></span><br></pre></td></tr></table></figure><ul><li>引用必须初始化。</li><li>引用和它的初始值是<strong>绑定bind</strong>在一起的，而<strong>不是拷贝</strong>。一旦定义就不能更改绑定为其他的对象</li><li><code>&amp;</code> 符号可以紧靠基本类型(<code>int</code>), 也可以紧靠变量名</li></ul><p><strong>以上说的引用都是左值引用，C++11还有右值引用</strong></p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针</strong> 是 “指向” 另外一种类型的复合类型。指针和引用的不同，指针本身是一个对象，允许对指针赋值和拷贝；指针无须在定义时赋初值。</p><p>指针的定义，将声明符写成 <code>*d</code> 的形式，其中 <code>d</code> 是变量名，如果一条语句种定义类几个指针变量，每个变量前面都必须有符号 <code>*</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1, *p2;<span class="comment">// ip1和ip2都是指向int型对象的指针</span></span><br><span class="line"><span class="type">double</span> dp, *dp2;<span class="comment">//dp2实质性double型对象的指针，dp是double型对象</span></span><br></pre></td></tr></table></figure><h4 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h4><p>指针的值应属下列4种状态之一：</p><ul><li>1.指向一个对象；</li><li>2.指向紧邻对象的下一个位置；</li><li>3.空指针, 意味着指针没有指向任何对象</li><li>4.无效指针, 也就是上述情况之外的其他值</li></ul><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>空指针不指向任何对象，在操作指针之前必须确定为一个非空指针。下列几个生成空指针的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;<span class="comment">// 等价于 int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;<span class="comment">// 直接将 p2初始化为字面常量0</span></span><br><span class="line"><span class="comment">// 需要首先 #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">// 等价于 int *p3 = 0;</span></span><br></pre></td></tr></table></figure><blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**建议：初始化所有指针。**</span><br><span class="line"></span><br><span class="line">#### 定义多个变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>int *p1, p2;   &#x2F;&#x2F; p1是指向int的指针, *是对p1的修饰, p2是int</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 指向指针的引用</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int i = 42;</span><br><span class="line">int *p;// p是int型的指针</span><br><span class="line">int *&amp;r = p;// r是一个对指针p的引用</span><br><span class="line">// &amp;离r最近, 因此r是一个引用, 声明符的其余部分用以确定r引用的类型是什么, int *说明r引用的是一个int指针</span><br><span class="line"></span><br><span class="line">r = &amp;i;// r是一个指针引用，因此给r赋值&amp;i就是令p指向i</span><br><span class="line">*r = 0;// 解引用r,就是解引用指针p,将p指向的变量i的值改为0</span><br></pre></td></tr></table></figure><blockquote><p>面对一条比较复杂的指针或引用的声明语句时，从右向左读有助于弄清楚它的真实含义。</p></blockquote><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++primer-5th-阅读笔记第一章</title>
      <link href="/2022/07/05/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2022/07/05/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><p><img src="/2022/07/05/C-primer-5th-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20221011191053151.png" alt="image-20221011191053151"></p><p>上图是一个 C 程序（C++ 程序类似）的编译过程，可供参考。</p><p>**g++**：</p><ul><li>编译：<code>g++ --std=c++11 ch01.cpp -o main</code></li><li>运行：<code>./prog1</code></li><li>查看运行状态：<code>echo $?</code></li><li>编译多个文件:<code>g++ ch2.cpp Sales_item.cc -o main</code></li></ul><p>输入 <code>g++ --help</code>，可查看编译器选项</p><h2 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h2><p>标准库定义类4个 IO 对象。输入， 使用一个名为 <code>cin</code> 的 <code>istream</code>  类型的对象。 输出，使用一个名为 <code>cout</code> 的 <code>ostream</code> 类型的对象。标准库还定义了其他两个 <code>ostream</code> 对象，名为 <code>cerr</code> 和 <code>clog</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2</span><br><span class="line">              &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/05/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/05/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p>建立博客的目的 是交流 与 记录 ！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
